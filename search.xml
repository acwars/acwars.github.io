<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solutions</title>
      <link href="2021/07/21/notes/computer_sciences/c/c_programming_a_modern_approach/"/>
      <url>2021/07/21/notes/computer_sciences/c/c_programming_a_modern_approach/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第3章-格式化输入输出">第3章 格式化输入/输出</h1><p>练习题</p><ol type="1"><li></li></ol><ol type="a"><li><pre><code>86,1040</code></pre></li><li>3.02530e+01 (c)83.1620 (d)1e-06</li></ol><ol start="2" type="1"><li><p>(a)printf("%-8.1e", x); (b)printf("%10.6e", x); (c)printf("-8.3g", x); (d)printf("6.0g", x);</p></li><li><p>(a)等价</p></li></ol><blockquote><p>格式串中包含空白字符不代表输入中必须包含空白字符.</p></blockquote><blockquote><p>格式串中的一个空白字符可以与输入中<em>任意</em>数量的空白字符相匹配, 包括零个.</p></blockquote><p>(b)不等价.</p><blockquote><p>"%d -%d -%d"在匹配格式串时, 会把 -%d留给下一次scanf函数调用来读取.</p></blockquote><p>(c)不等价</p><blockquote><p>"%f "格式串可能会导致交互式程序一直"挂起", 直到用户输入一个非空白字符为止.</p></blockquote><p>(d)等价</p><ol start="4" type="1"><li><p>i = 10 x = 0.300000 j = 5</p></li><li><p>x = 12.3 y = 45 i = 0.600000</p></li><li><p>在scanf中字符"/"的前后添加空格.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solutions</title>
      <link href="2021/07/21/notes/computer_sciences/overview/foundations_of_computer_science/"/>
      <url>2021/07/21/notes/computer_sciences/overview/foundations_of_computer_science/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第1章-绪论">第1章 绪论</h1><h2 id="复习题">复习题</h2><ol type="1"><li></li></ol><h2 id="练习题">练习题</h2><h1 id="第2章-数字系统">第2章 数字系统</h1><h2 id="复习题-1">复习题</h2><ol type="1"><li>一套用符号来表达数字的系统</li><li>位置化数字系统: 符号所在的位置决定了符号的值.  非位置化数字系统: 符号所在的位置与符号的的值无关.</li><li></li></ol><h2 id="练习题-1">练习题</h2><h1 id="第3章-数据存储">第3章 数据存储</h1><h2 id="复习题-2">复习题</h2><ol type="1"><li></li></ol><h2 id="练习题-2">练习题</h2><h1 id="第5章-计算机组成">第5章 计算机组成</h1><h2 id="复习题-3">复习题</h2><ol type="1"><li>中央处理单元(CPU)、主存储器、输入/输出子系统.</li><li>算术逻辑单元(ALU)、控制单元、寄存器组</li><li>在程序执行过程中用于执行逻辑运算和算术运算</li><li>负责监视所有指令的执行和各种信息的传输过程</li><li></li></ol><h2 id="练习题-3">练习题</h2>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Irregular Verbs</title>
      <link href="2020/10/22/notes/english_grammar_in_use/appendix_01/"/>
      <url>2020/10/22/notes/english_grammar_in_use/appendix_01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="list-of-irregular-verbs">List of irregular verbs</h1><h2 id="b">B</h2><table><thead><tr class="header"><th>Infinitive</th><th>Past</th><th>Past Participle</th></tr></thead><tbody><tr class="odd"><td>be</td><td>was/were</td><td>been</td></tr><tr class="even"><td>bear</td><td>bore</td><td>borne</td></tr><tr class="odd"><td>beat</td><td>beat</td><td>beat</td></tr><tr class="even"><td>begin</td><td>began</td><td>begun</td></tr><tr class="odd"><td>bend</td><td>bent</td><td>bent</td></tr><tr class="even"><td>beseech</td><td>besought</td><td>besought</td></tr><tr class="odd"><td>bet</td><td>bet also betted</td><td>bet also betted</td></tr><tr class="even"><td>bid(to express)</td><td>bade</td><td>bidden</td></tr><tr class="odd"><td>bid(to offer)</td><td>bid</td><td>bid</td></tr><tr class="even"><td>bind</td><td>bound</td><td>bound</td></tr><tr class="odd"><td>bite</td><td>bit</td><td>bitten</td></tr><tr class="even"><td>bleed</td><td>bled</td><td>bled</td></tr><tr class="odd"><td>blow</td><td>blew</td><td>blown</td></tr><tr class="even"><td>break</td><td>broke</td><td>broken</td></tr><tr class="odd"><td>breed</td><td>bred</td><td>bred</td></tr><tr class="even"><td>bring</td><td>brought</td><td>brought</td></tr><tr class="odd"><td>build</td><td>built</td><td>built</td></tr><tr class="even"><td>burn</td><td>burnt</td><td>burnt</td></tr><tr class="odd"><td>burst</td><td>burst</td><td>burst</td></tr><tr class="even"><td>bust</td><td>busted</td><td>busted</td></tr><tr class="odd"><td>buy</td><td>bought</td><td>bought</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> English Grammar in Use </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grammar</title>
      <link href="2020/10/22/notes/english_grammar_in_use/grammar/"/>
      <url>2020/10/22/notes/english_grammar_in_use/grammar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      
      
      <categories>
          
          <category> English Grammar in Use </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discrete Mathematics</title>
      <link href="2020/10/22/notes/math/discrete_mathematics/"/>
      <url>2020/10/22/notes/math/discrete_mathematics/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="数理逻辑">数理逻辑</h2><p>表达风格</p><p>表达一些让人易于理解的数学概念和思路的时候应该注意两点:</p><blockquote><ol type="1"><li>表达的数学概念和思路是正确的   2. 使用正确的表达风格</li></ol></blockquote><p>在书写严格的证明时，更多地还是倾向于使用文字表达，因为这样的表达会更易于理解。</p><p>命题</p><p>命题的定义</p><blockquote><ol type="1"><li>陈述句   2. 只能取"真"或"假"其中一个值</li></ol></blockquote><p>复合命题的定义</p><blockquote><p>一个命题若能分解为若干个更简单的命题</p></blockquote><p>简单命题的定义</p><blockquote><p>一个命题若不能分解再为更简单的命题</p></blockquote><p>逻辑复合</p><p>否定连结词 <span class="math inline">\(\neg\)</span></p><blockquote><p><span class="math inline">\(\neg\)</span> 读作 not(非) 表示对命题的否定</p></blockquote><p><span class="math inline">\(\neg\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th><span class="math inline">\(\neg\)</span> p</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>0</td></tr></tbody></table><p>合取联结词 <span class="math inline">\(\wedge\)</span></p><blockquote><p><span class="math inline">\(\wedge\)</span> 读作 and(且), 当两个命题都为真时，命题才为真</p></blockquote><p><span class="math inline">\(\wedge\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\wedge\)</span> q</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>析取联结词 <span class="math inline">\(\vee\)</span></p><blockquote><p><span class="math inline">\(\vee\)</span> 读作 or(或), 当两个命题中有任意一个为真时, 命题为真, 两个命题都为真时, 命题也为真</p></blockquote><p><span class="math inline">\(\vee\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\vee\)</span> q</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>异或 <span class="math inline">\(\oplus\)</span></p><blockquote><p><span class="math inline">\(\oplus\)</span> 读作 xor或者exclusive or(异或), 当两个命题中有一个为真时， 命题为真; 如果两个命题都为假， 命题为假; 如果两个命题都为真, 因为异或的互斥性, 命题为假</p></blockquote><p><span class="math inline">\(\oplus\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\oplus\)</span> q</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>蕴含复合</p><p>蕴含联结词 <span class="math inline">\(\rightarrow\)</span></p><blockquote><p>前件 &gt; 如<span class="math inline">\(\cdots\)</span>, 在"如果"之后的命题称之为前件</p></blockquote><blockquote><p>后件 &gt; 则<span class="math inline">\(\cdots\)</span>, 在"则"之后的命题称之为后件</p></blockquote><blockquote><p>简写 &gt; 如果<span class="math inline">\(\cdots\)</span>, 则<span class="math inline">\(\cdots\)</span>简写为 <span class="math inline">\(\cdots\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\cdots\)</span></p></blockquote><p><span class="math inline">\(\rightarrow\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\rightarrow\)</span> q</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>1</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>Tips</p><blockquote><p>当且仅当命题的前件为真且后件为假时, 命题为假, 其余情况都为真</p></blockquote><p>逆命题</p><blockquote><p>原命题的前件作为新命题的后件, 原命题的后件作为新命题的前件</p></blockquote><p>逆命题的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\rightarrow\)</span> q</th><th>q <span class="math inline">\(\rightarrow\)</span> p</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>等价联结词 <span class="math inline">\(\leftrightarrow\)</span></p><blockquote><p><span class="math inline">\(\leftrightarrow\)</span> 读作 equivalents(<span class="math inline">\(\cdots\)</span>等价于<span class="math inline">\(\cdots\)</span> 或 <span class="math inline">\(\cdots\)</span>和<span class="math inline">\(\cdots\)</span>等价), 有时候也会使用"<span class="math inline">\(\cdots\)</span>当且仅当<span class="math inline">\(\cdots\)</span>"这种方式来表达</p></blockquote><p><span class="math inline">\(\leftrightarrow\)</span> 的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th>p <span class="math inline">\(\leftrightarrow\)</span> q</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>1</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>逆否命题</p><blockquote><p>对于一个命题, 取命题的否定, 得到<span class="math inline">\(\neg\)</span>命题, 并把原命题的<span class="math inline">\(\neg\)</span>前件作为新命题的后件, 原命题的<span class="math inline">\(\neg\)</span>后件作为新命题的前件 与逆命题不同, 逆否命题<span class="math inline">\(\leftrightarrow\)</span>原命题</p></blockquote><p>逆否命题的真值表如下</p><table><thead><tr class="header"><th>p</th><th>q</th><th><span class="math inline">\(\neg\)</span> p</th><th><span class="math inline">\(\neg\)</span> q</th><th>p <span class="math inline">\(\rightarrow\)</span> q</th><th><span class="math inline">\(\neg\)</span> q <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\neg\)</span> p</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>化简逻辑表达</p><p>当一个命题被多次复合之后, 会得到一些比较复杂的命题. 对于一个复杂的命题p,如果可以通过化简得到一个命题q, 那么我们说</p><p><span class="math display">\[ p \Leftrightarrow q\]</span></p><p><span class="math inline">\(\Leftrightarrow\)</span></p><blockquote><p>这表示它们具备相同的取值, 也称这两个命题等价.</p></blockquote><p>一些常见的等价情况</p><ol type="1"><li><span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span> p <span class="math inline">\(\Leftrightarrow\)</span> p</li><li>p <span class="math inline">\(\rightarrow\)</span> q <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\neg\)</span> p <span class="math inline">\(\vee\)</span> q</li><li>p <span class="math inline">\(\vee\)</span> (p <span class="math inline">\(\wedge\)</span> q) <span class="math inline">\(\Leftrightarrow\)</span> p</li><li>p <span class="math inline">\(\vee\)</span> <span class="math inline">\(\neg\)</span> p <span class="math inline">\(\Leftrightarrow\)</span> True</li><li>p <span class="math inline">\(\wedge\)</span> <span class="math inline">\(\neg\)</span> p <span class="math inline">\(\Leftrightarrow\)</span> False</li></ol><p>逻辑运算定律</p><p>交换律</p><span class="math display">\[\begin{aligned}    p \wedge q &amp;\Leftrightarrow q \wedge p \\    p \vee q &amp;\Leftrightarrow q \vee p\end{aligned}\]</span><p>分配律</p><span class="math display">\[\begin{aligned}    p \wedge (q \vee r) &amp;\Leftrightarrow (p \wedge q) \vee p \wedge r) \\    p \vee (q \wedge r) &amp;\Leftrightarrow (p \vee q) \wedge (p \vee r)\end{aligned}\]</span><p>德·摩根律</p><span class="math display">\[\begin{aligned}    \neg (A \wedge B) \Leftrightarrow \neg A \vee \neg B \\    \neg (A \vee B) \Leftrightarrow \neg A \wedge \neg B\end{aligned}\]</span><p>综合运用 <em>求 <span class="math inline">\(\neg\)</span> (A <span class="math inline">\(\rightarrow\)</span> B)</em></p><span class="math display">\[\begin{aligned}    A \rightarrow B &amp;\Leftrightarrow \neg A \vee B \\    \neg (A \rightarrow B) &amp;\Leftrightarrow \neg (\neg A \vee B) \\    \neg \neg A \wedge \neg B &amp;\Leftrightarrow A \wedge \neg B\end{aligned}\]</span><em><span class="math inline">\(\neg\)</span> ((x <span class="math inline">\(\rightarrow\)</span> y) <span class="math inline">\(\wedge\)</span> <span class="math inline">\(\neg\)</span> x) <span class="math inline">\(\Leftrightarrow\)</span> x</em><br />根据德·摩根律可得<br /><span class="math display">\[\begin{aligned}    \neg (x \rightarrow y) \vee \neg \neg x &amp;\Leftrightarrow \neg (\neg x \vee y) \vee x \\    &amp;\Leftrightarrow (\neg \neg x \wedge \neg y) \\    &amp;\Leftrightarrow (x \wedge \neg y) \vee x \\    &amp;\Leftrightarrow x\end{aligned}\]</span><p>谓词逻辑</p><p>谓词逻辑与变量</p><blockquote><p>谓词逻辑关注的是<strong>变量</strong>和可以接受变量作为输入值的<strong>谓词</strong>. 在这里, 谓词可以接受不同的输入变量, 当输入变量被赋予一个具体的<strong>主词</strong>时, "谓语 + 主词"的整体就成为了一个可以判断真假的命题</p></blockquote><p>谓词逻辑与量词</p><p>全称量词 <span class="math inline">\(\forall\)</span></p><blockquote><p><span class="math inline">\(\forall\)</span> 读作对于所有的, 用于代替全称代词</p></blockquote><p>存在量词 <span class="math inline">\(\exists\)</span></p><blockquote><p><span class="math inline">\(\exists\)</span> 读作存在, 用于代替存在量词</p></blockquote><p>唯一存在量词</p><blockquote><p>在存在量词的基础上增加了对唯一性的描述</p></blockquote><p>否定时的一些规则总结</p><ul><li>对于陈述中带有谓词的否定<ul><li><span class="math inline">\(\forall\)</span> 要变为 <span class="math inline">\(\exists\)</span></li><li><span class="math inline">\(\exists\)</span> 要变为 <span class="math inline">\(\forall\)</span></li></ul></li><li>命题后件中带有<span class="math inline">\(\vee\)</span>、<span class="math inline">\(\wedge\)</span>复合的否定<ul><li><span class="math inline">\(\vee\)</span> 要变成 <span class="math inline">\(\wedge\)</span></li><li><span class="math inline">\(\wedge\)</span> 要变成 <span class="math inline">\(\vee\)</span></li></ul></li><li>复杂的否定可以通过简化逻辑表达来进行简化</li></ul><h3 id="命题证明">命题证明</h3><p>全称命题</p><blockquote><p>开始于<span class="math inline">\(\forall\)</span>的陈述句, 如果它可以被唯一地确定真假</p></blockquote><p>例 对于任意的有理数<span class="math inline">\(q\)</span>, <span class="math inline">\(2q\)</span>也是有理数</p><span class="math display">\[\begin{aligned}证: \\    &amp; 对于一个任意选择的有理数q, 根据定义可知q = \frac{m}{n}  m,n 为整数 (n \neq 0) \\    &amp; 等式两边同时乘以2可得    2q = \frac{2m}{n} \\    &amp; \because m为整数 \\    &amp; \therefore 2m也为整数 \\    &amp; \therefore \frac{2m}{n}是一个合法的有理数定义方式, 2q是有理数\end{aligned}\]</span><p>例 对于任意整数<span class="math inline">\(k\)</span>, 如果<span class="math inline">\(k\)</span>是偶数, 那么 <span class="math inline">\(k^{2}\)</span>是偶数</p><span class="math display">\[\begin{aligned}证: \\    &amp; 因为k是偶数, 所以存在一个整数t, 使得k = 2t \\    &amp; 因此可得 k^{2} = (2t)^2 = 4t^{2} \\    &amp; 4t^{2}可表示为2 \cdot 2t^{2} \\    &amp; \because t是整数 \\    &amp; \therefore 2t^{2}也是整数, 记为p \\    &amp; 由此可知: 存在一个整数p, 使k^{2} = 2p \\    &amp; \therefore k^{2}是偶数\end{aligned}\]</span><p>特称命题</p><blockquote><p>开始于存在量词的陈述句, 如果它可以被唯一地确定真假</p></blockquote><p>命题的证伪</p><p>如果我们怀疑一个命题是假命题, 可以对这个命题进行证伪<br />对于命题, 通过以上学习, 我们可以得到这样的情况分析:</p><blockquote><p>从定义进行的命题证明都不能举特例去证明 可以通过正例和反例进行的证明则没有必要去再做复杂证明, 只要举例并说明合理性就足够了</p></blockquote><table><thead><tr class="header"><th>命题分类</th><th>证明</th><th>证伪</th></tr></thead><tbody><tr class="odd"><td>全称命题</td><td>从定义证明</td><td>举一个反例</td></tr><tr class="even"><td>存在命题</td><td>举一个正例</td><td>从定义证明</td></tr></tbody></table><p>双变量的命题证明</p><p>例 对于任意两个整数<span class="math inline">\(m, n, m\)</span>和<span class="math inline">\(n\)</span>是完全平方数, 那么<span class="math inline">\(mn\)</span>也是完全平方数</p><blockquote><p>Tips &gt; 对于一个整数n, 如果存在某一个整数k可以使得<span class="math inline">\(n = k^{2}\)</span>那么n是一个完全平方数</p></blockquote><span class="math display">\[\begin{aligned}证: \\    &amp; 假设整数m和整数n是完全平方数 \\    &amp; 根据完全平方的定义, 存在整数k和整数j使得m = k^{2}且n = j^{2} \\    &amp; 那么mn就可以被表示为k^{2}j^{2}, 也就是(kj)^{2}. \\    &amp; \because k和j都是整数 \\    &amp; \therefore kj也是整数 \\    &amp; \therefore mn = (kj)^{2}是一个完全平方数\end{aligned}\]</span><p>例 对于任一整数<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>, 如果<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>是奇数, 那么<span class="math inline">\(j+k\)</span>是偶数</p><span class="math display">\[\begin{aligned}证: \\    &amp; 令整数j和k为奇数 \\    &amp; \because j, k是奇数 \\    &amp; \therefore 存在整数p, q使得j = 2p + 1, k = 2q + 1 \\    &amp; 由此可得j + k = 2p + 1 + 2q + 1 = 2(p + q + 1) \\    &amp; 已知p和q是整数, p + q也是一个整数 \\    &amp; 令t = p + q + 1 \\    &amp; 根据偶数的定义, 可知2t为偶数 \\    &amp; \therefore j + k = 2(p + q + 1) = 2t是偶数\end{aligned}\]</span><p>分类讨论</p><blockquote><p>在思考一个问题并且通过证明进行表达的过程中, 不仅会遇到顺序推理的证明方式, 也可能遇到多种不同情况需要区别对待、分别证明的场景. 在这种场景下, 会在证明中引入分类讨论</p></blockquote><p>例 <span class="math inline">\(\forall j, k\)</span>, 如果<span class="math inline">\(j\)</span>是偶数或<span class="math inline">\(k\)</span>是偶数, 则<span class="math inline">\(jk\)</span>是偶数</p><span class="math display">\[\begin{aligned}证: \\    &amp; 情况1: 如果j是偶数 \\    &amp; 根据偶数的定义, 一定存在一个整数m满足j = 2m \\    &amp; 由此可得jk = 2(m)k = 2(mk) \\    &amp; \because m和k都为整数 \\    &amp; \therefore mk也是一个整数 \\    &amp; 根据偶数的定义, 可知2(mk)是一个偶数 \\    &amp; \therefore jk = 2(mk)是一个偶数 \\    \\    &amp; 情况2: \quad 如果k是偶数 \\    &amp; 根据偶数的定义, 一定存在一个整数n满足k = 2n \\    &amp; 由此可得jk = (2n)j = 2(nj) \\    &amp; \because n和j都为整数 \\    &amp; \therefore nj也是一个整数 \\    &amp; 根据偶数的定义, 可知2(nj)是一个偶数 \\    &amp; \therefore jk = 2 (nj)是一个偶数\end{aligned}\]</span><blockquote><p>Notes: 在实际问题中, 需要分的情况往往会更多, 有的时候甚至在一个分类讨论里, 再进行一层的分类讨论. 对于复杂的情况, 一定确保列出的情况覆盖了所有的可能性, 不然不能将其视为完整的证明.</p></blockquote><p>等价转换与逆否命题</p><p>如果希望证明的原命题是<span class="math inline">\(\forall x, P(x) \rightarrow Q(x)\)</span>, 那么也可以去证明与它等价的逆否命题<span class="math inline">\(\forall x, \neg Q(x) \rightarrow \neg P(x)\)</span></p><p>例 对于任一整数<span class="math inline">\(k\)</span>, 如果<span class="math inline">\(3k + 1\)</span>是偶数, 那么<span class="math inline">\(k\)</span>一定是奇数</p><span class="math display">\[\begin{aligned}证: \\    &amp; 对于任一整数k, 如果k是偶数, 那么3k + 1是奇数 \\    &amp; 根据偶数的定义, 一定存在一个整数m满足k = 2m \\    &amp; 由此可得 3k + 1 = 3(2m) + 1 = 2(3m) + 1 \\    &amp; \because m是一个整数 \\    &amp; \therefore 2(3m)也是一个整数 \\    &amp; 根据奇数的定义, 可知2(3m) + 1是一个奇数\end{aligned}\]</span><h2 id="集合论">集合论</h2><p>什么是集合</p><blockquote><p>一般来讲, 具有某种相同属性的食物, 其全体就构成一个集合. 构成这个集合的事物, 就称为该集合的<strong>元</strong>或<strong>元素</strong>.</p></blockquote><blockquote><p>根据所给的属性, 总是能判断任一事物是否属于某个集合, 而不会含糊不清</p></blockquote><p>集合的表示</p><blockquote><p>通常用非特殊字体的大写字母<span class="math inline">\(A, B, C \cdots\)</span>表示集合, 而用小写字母<span class="math inline">\(a, b, c \cdots\)</span>来表示集合中的元素.</p></blockquote><blockquote><p>如果<span class="math inline">\(a\)</span>是集合<span class="math inline">\(B\)</span>中的一个元素, 将其记为<span class="math inline">\(a \in B\)</span>; 如果<span class="math inline">\(a\)</span>不是集合<span class="math inline">\(B\)</span>中的一个元素, 则将其记为<span class="math inline">\(a \notin B\)</span></p></blockquote><blockquote><p>如果一个集合中不包含有任何元素, 称其为空集, 记为<span class="math inline">\(\emptyset\)</span></p></blockquote><p>集合的表示方式</p><ol type="1"><li>列举法, 例如{C语言程序设计, C++程序设计, 数据结构, 计算机科学导论}.</li><li>谓词描述法, 记为<span class="math inline">\(S = \{x|P{x} \}\)</span>形式, 例如<span class="math inline">\(S = \{x|x^{2} - 1 = 0 \}\)</span></li></ol><p>形如<span class="math inline">\(S = \{x|P(x) \}\)</span>的这种谓词描述方式分为两个部分 1. 在分隔符前的部分是一个代表了集合中所有元素的变量 2. 在分隔符后的部分是由一个或多个集合中元素都必须满足的条件组成的谓词</p><p>集合的性质 1. 无序性: 不讨论集合中元素被列出的顺序 2. 唯一性: 不论在集合的表示中, 元素写了多少遍</p><p>集合的势</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The Real Analysis Lifesaver</title>
      <link href="2020/10/22/notes/math/the_real_analysis_life_saver/"/>
      <url>2020/10/22/notes/math/the_real_analysis_life_saver/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
